Each iterative stage involves repeating a set of actions. After preparing the training dataset, the target object—the attractor (service tag) to be predicted in the current iteration—is determined. Next, a two-part program code is applied.

The first part of the code analyzes transport infrastructure (bus and tram stops, subway stations) and nearby buildings containing information about attractors and service tags (Appendix 1). The code creates a graph representing interactions between building points and transport infrastructure. Building points with attractors and tags are input into the graph as nodes with attributes (coordinates, residential area, and replenished population). Edges connect points within a specified distance or the nearest ones if no others are nearby.

The second part of the code implements a graph binary classification task using a Graph Convolutional Network (GCN) [20] with the PyTorch Geometric library (Appendix 2). The function loads the graph from a file prepared in the previous step using the pickle module and returns a graph object represented by the NetworkX library. A list of node attributes is created, including area, residential area, number of tags, etc. The node type (bus stop, tram stop, or subway station) and a binary indicator of the presence of an attractor are also added. The GCN model implements a graph convolutional network with *n* layers. Normalization and an activation function are applied between layers. The model is then trained, and evaluation metrics are displayed after each epoch.
